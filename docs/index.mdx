---
title: What are virtual clusters?
slug: /
sidebar_position: 1
hide_table_of_contents: false
---

import WhatAreVirtualClusters from '@site/docs/_fragments/virtual-cluster-content.mdx'

Virtual clusters provides isolation to support multi-tenancy within a single physical Kubernetes cluster. This means multiple users or teams can operate independently within the same physical infrastructure while mimizing conflicts, maximizing autonomy, and reducing costs. 

<figure>
<img
  src={require('@site/static/media/diagrams/vcluster-architecture.png').default}
  alt="vCluster Comparison"
 />
  <figcaption>vCluster Architecture</figcaption>
</figure>

Virtual clusters run inside a namespace of a host cluster but function as separate Kubernetes clusters, with their own API server, control plane, syncer and set of resources. While vClusters share the physical resources of the host cluster (such as CPU, memory, and storage), they manage their resources independently, allowing for efficient utilization and scaling. 

Virtual clusters interact with the host cluster for resources scheduling and networking but maintain a level of abstraction to ensure operations within a vCluster don't directly affect the host cluster's global state.

## Benefits of vCluster
Virtual clusters provide immense benefits for large-scale Kubernetes deployments and multi-tenancy

<figure>
<img
  src={require('@site/static/media/diagrams/vcluster-comparison.png').default}
  alt="vCluster Comparison"
 />
  <figcaption>vCluster Comparison</figcaption>
</figure>

#### Give Full Admin Access per Tenant
    - Freely deploy operators with CRDs, create namespaces and other cluster-scoped resources that you normally can't create inside a namespace.
    - Taint and label nodes without influencing the host cluster. 
    - Reuse and share services across multiple virtual clusters with ease.
#### Reduce Costs
    - Create lightweight vCluster instances that share the underlying host cluster instead of creating separate "physical" clusters.
    - Auto-scale, purge, snapshot, and move your vCluster instances, since they are essentially Kubernetes deployments.
#### Lower Your Overhead
    - vCluster instances are super lightweight and only reside in a single namespace.
    - vCluster instances run with vanilla K8s. You can use other supported distributions such as [K3s](https://k3s.io/), and [K0s](https://k0sproject.io/).
    - The vCluster control plane runs inside a single pod. Open source vCluster also uses a CoreDNS pod for vCluster-internal DNS capabilities. With vCluster Platform, however, you can enable the integrated CoreDNS so you don't need the additional pod.
#### No Network Degradation
    - Since the pods and services inside a vCluster are actually being synchronized down to the host cluster, they are effectively using the underlying cluster's pod and service networking. The vCluster pods are as fast as other pods in the underlying host cluster.
#### API Server Compatibility
    - vCluster instances run with the API server from the Kubernetes distribution that you choose to use. This ensures 100% Kubernetes API server compliance.
    - vCluster manages its API server, controller-manager, and a separate, isolated data store. Use the embedded SQLite, embedded etcd, a full-blown etcd or external relational databases if that's what you need.
#### Enhance Security
    - vCluster users need fewer permissions in the underlying host cluster / host namespace.
    - vCluster users can manage their own CRDs independently and can even modify RBAC inside their own vCluster instances.
    - vCluster instances provide an extra layer of isolation. Each vCluster manages its own API server and control plane, which means that fewer requests to the underlying cluster need to be secured.
#### Improve Scalability
    - Less pressure / fewer requests on the K8s API server in a large-scale cluster.
    - Higher scalability of clusters via cluster sharding / API server sharding into smaller vCluster instances.
    - No need for cluster admins to worry about conflicting CRDs or CRD versions with a growing number of users and deployments.

## Common Use Cases
### Pre-production
   - **Empower developers with self-service Kubernetes:** Simplify Kubernetes access for developers through self-service virtual clusters, reducing human error and enhancing developer autonomy without compromising security and compliance requirements.
   - **Accelerate CI/CD with ephemeral Kubernetes clusters:** Instantly create clean, new virtual Kubernetes clusters for each pull request, enabling fast, isolated testing and PR previews without wait times and without the struggles of a shared test environment.

### Production
   - **Elevate your ISV offering with a dedicated cluster per customer:** Host each customer in a virtual cluster with strict tenant isolation and seamless scalability, while consolidating essential tools into a unified platform stack serving multiple tenants.
   - **Build a managed Kubernetes service with best-in-class COGS and high margins:** Enable direct customer access to dedicated virtual Kubernetes clusters, streamlining node and resource allocation for industry-leading efficiency and unparalleled scalability.