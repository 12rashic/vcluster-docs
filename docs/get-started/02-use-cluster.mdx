---
title: Use Your Virtual Cluster
sidebar_label: 2. Use Virtual Cluster
description: Learn how connect to and use your virtual cluster.
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

## Learning objectives

@TODO fill out this section after completing the rest of the section (or eliminate)


## Retrieve the virtual cluster kubeconfig

There might be cases where connecting to a vCluster with the CLI is not feasible or the CLI cannot be installed. For such cases, you can retrieve the vCluster kubeconfig from a secret that is created automatically in the vCluster namespace.

The secret is prefixed with `vc-` and ends with the vCluster name, so a vCluster called `my-vcluster` in namespace `test` would create a secret called `vc-my-vcluster` in the namespace `test`. 

<Tabs
  groupId="get-started"
  defaultValue="cli"
  values={[
	{ label: "CLI", value: "cli" },
    { label: 'Helm', value: 'helm', },
    { label: 'kubectl', value: 'kubectl', },
    { label: 'Terraform', value: 'terraform', },
    { label: 'Argo CD', value: 'argo', },
    { label: 'Cluster API', value: 'cluster-api', },
  ]
}>
<TabItem value="cli">

@TODO CLI retrieve virtual cluster kubeconfig

</TabItem>
<TabItem value="helm">

@TODO Helm retrieve kubeconfig

</TabItem>
<TabItem value="kubectl">

```bash
kubectl get secret vc-my-vcluster -n test --template={{.data.config}} | base64 -D
```

</TabItem>
<TabItem value="terraform">

@TODO Terraform retrieve kubeconfig

</TabItem>
<TabItem value="argo">

@TODO Argo CD retrieve kubeconfig

</TabItem>
<TabItem value="cluster-api">

@TODO Cluster API retrieve kubeconfig

</TabItem>
</Tabs>

The secret holds a kubeconfig in this format:

```yaml
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: LS0t...
    server: https://localhost:8443
  name: local
contexts:
- context:
    cluster: local
    namespace: default
    user: user
  name: Default
current-context: Default
kind: Config
users:
- name: user
  user:
    client-certificate-data: LS0tLS...
    client-key-data: LS0tLS...
```


## Connect to your virtual cluster

You can use the CLI to quickly connect to your virtual cluster. Execute:

```bash
vcluster connect my-cluster
```

Output is similar to:

```bash
done Switched active kube context to vcluster_my-cluster
- Use `vcluster disconnect` to return to your previous kube context
```

You can retrieve a list of vCluster instance names by running `vcluster list`.

By default, the vCluster CLI connects to the virtual cluster either directly (on local Kubernetes distributions) or via port-forwarding for remote clusters. If you want to use vCluster on remote clusters without port-forwarding, you can take a look at other supported exposing methods.

## Run kubectl commands

A virtual cluster behaves the same way as a regular Kubernetes cluster. That means you can run any `kubectl` command. Since you are admin of this vCluster, you can even run commands like these:

```bash
kubectl get namespace
kubectl get pods -n kube-system
```

## What happens in the host cluster

To illustrate what happens in the host cluster, create a namespace and deploy NGINX:

```bash
kubectl create namespace demo-nginx
kubectl create deployment nginx-deployment -n demo-nginx --image=nginx -r 2
```

Check that this deployment creates two pods inside the virtual cluster:

```bash
kubectl get pods -n demo-nginx
```

Output is similar to:

```bash
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-6d6565499c-2wfrd   1/1     Running   0          9s
nginx-deployment-6d6565499c-2blwr   1/1     Running   0          9s
```

**Most** resources inside your virtual cluster only exist in your virtual cluster and **not** in the underlying host cluster / host namespace.

To verify this, perform these steps:

1. Switch back to the host context.

   ```bash
   vcluster disconnect
   ```

1. Check namespaces in the host cluster.

   ```bash 
   kubectl get namespaces
   ```

   Output is similar to:

   ```bash {3}
   NAME                 STATUS   AGE
   default              Active   11d
   vcluster-my-vcluster Active   9m17s
   kube-node-lease      Active   11d
   kube-public          Active   11d
   kube-system          Active   11d
   ```

   Notice that there is **no namespace `demo-nginx`** because this namespace only exists inside the virtual cluster. 
   
   Everything that belongs to the virtual cluster always remains inside the vCluster's `vcluster-my-vcluster` namespace.

1. Look for the NGINX deployment.

   Check to see if your deployment `nginx-deployment` is in the underlying host cluster.

   ```bash
   kubectl get deployments -n vcluster-my-cluster
   ```

   Output is similar to:

   ```bash
   No resources found in vcluster-my-cluster namespace.
   ```

   You see that there is no deployment `nginx-deployment` because that deployment only lives inside the virtual cluster.

1. Look for the NGINX pods.

   The last thing to check is pods running inside the virtual cluster namespace:

   ```bash
   kubectl get pods -n vcluster-my-cluster
   ```

   Output is similar to:

   ```bash {4-5}
   NAME                                                          READY   STATUS    RESTARTS   AGE
   coredns-68bdd584b4-9n8c4-x-kube-system-x-my-cluster           1/1     Running   0          129m
   my-cluster-0                                                  1/1     Running   0          129m
   nginx-deployment-6d6565499c-2blwr-x-demo-nginx-x-my-cluster   1/1     Running   0          7m25s
   nginx-deployment-6d6565499c-2wfrd-x-demo-nginx-x-my-cluster   1/1     Running   0          7m25s
   ```

   :::info Renaming
   As you see in lines 4-5 of the output, the pod name is rewritten during the sync process since vCluster is mapping pods from namespaces inside the virtual cluster into one single host namespace in the underlying host cluster.
   :::

   The vCluster `my-cluster-0` pod contains the virtual cluster’s API server and some additional tools. There’s also a CoreDNS pod, which vCluster uses, and the two NGINX pods.
   
   The host cluster has the `nginx-deployment` pods because the virtual cluster **does not** have separate nodes or a scheduler. Instead, the virtual cluster has a _syncer_ that synchronizes resources from the virtual cluster to the underlying host namespace.
   The vCluster syncer process tells the underlying cluster to schedule workloads. This syncer process communicates with the API server of the host cluster to schedule the pods and keep track of their state. 
   To prevent collisions, vCluster appends the name of the virtual cluster namespace the pods are running in and the name of the virtual cluster.

   Only very few resources and API server requests actually reach the underlying Kubernetes API server. Only workload-related resources (e.g. Pod) and networking-related resources (e.g. Service) need to be synchronized down to the host cluster since the vCluster does **not** have any nodes or network itself.
  
   The state of most objects running in the virtual cluster is stored in a database inside it. vCluster uses SQLite by default for that DB, but it can also use etcd or a few other options like PostgreSQL. But pods are scheduled in the host cluster.
